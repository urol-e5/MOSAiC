---
title: "Ortholog Expression"
description: "Select an ortholog group and view expression (mean ± SD) across three coral species over four time points"
format:
  html:
    code-copy: true
editor: visual
execute:
  echo: false
  warning: false
  message: false
---

```{r setup, include=FALSE}
required_packages <- c("tidyverse","readr","dplyr","tibble","jsonlite","htmltools","plotly")
for (pkg in required_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) try(utils::install.packages(pkg), silent = TRUE)
  suppressPackageStartupMessages(library(pkg, character.only = TRUE))
}

load_data_file <- function(path) {
  if (!file.exists(path)) return(tibble())
  df <- tryCatch(readr::read_csv(path, show_col_types = FALSE, progress = FALSE), error=function(e) NULL)
  if (is.null(df)) df <- tryCatch(readr::read_tsv(path, show_col_types = FALSE, progress = FALSE), error=function(e) NULL)
  if (is.null(df)) tibble() else df
}

load_data_url <- function(url) {
  df <- tryCatch(readr::read_csv(url, show_col_types = FALSE, progress = FALSE), error=function(e) NULL)
  if (is.null(df)) df <- tryCatch(readr::read_tsv(url, show_col_types = FALSE, progress = FALSE), error=function(e) NULL)
  if (is.null(df)) tibble() else df
}

create_mock_count_data <- function(genes) {
  set.seed(42)
  if (!length(genes)) genes <- paste0("Apul_GENE_", seq_len(10))
  tibble(gene_id = genes,
         TP1_rep1 = sample(0:100,length(genes),TRUE),
         TP1_rep2 = sample(0:100,length(genes),TRUE),
         TP2_rep1 = sample(0:100,length(genes),TRUE),
         TP2_rep2 = sample(0:100,length(genes),TRUE),
         TP3_rep1 = sample(0:100,length(genes),TRUE),
         TP3_rep2 = sample(0:100,length(genes),TRUE),
         TP4_rep1 = sample(0:100,length(genes),TRUE),
         TP4_rep2 = sample(0:100,length(genes),TRUE))
}

aggregate_gene_counts <- function(df){
  if (!nrow(df)) return(tibble())
  tp_cols <- grep('TP[1-4]', names(df), value=TRUE)
  if (!length(tp_cols)) return(tibble())
  tp_map <- tibble(col=tp_cols, tp=as.integer(stringr::str_match(tp_cols,'TP([1-4])')[,2]))
  rows <- lapply(seq_len(nrow(df)), function(i){
    gene <- df$gene_id[i]
    stats <- sapply(1:4, function(tp){
      cols <- tp_map$col[tp_map$tp==tp]
      if(!length(cols)) return(c(mean=NA_real_, sd=NA_real_))
      vals <- as.numeric(df[i, cols])
      c(mean=mean(vals, na.rm=TRUE), sd=if(length(na.omit(vals))>1) sd(vals, na.rm=TRUE) else 0)
    })
    tibble(gene_id=gene,
           TP1_mean=stats["mean",1], TP2_mean=stats["mean",2], TP3_mean=stats["mean",3], TP4_mean=stats["mean",4],
           TP1_sd=stats["sd",1],   TP2_sd=stats["sd",2],   TP3_sd=stats["sd",3],   TP4_sd=stats["sd",4])
  })
  list_rbind(rows)
}

calculate_z_scores <- function(df){
  if (!nrow(df)) return(tibble())
  tp_cols <- grep('TP[1-4]', names(df), value=TRUE)
  if (!length(tp_cols)) return(tibble())
  tp_map <- tibble(col=tp_cols, tp=as.integer(stringr::str_match(tp_cols,'TP([1-4])')[,2]))
  rows <- lapply(seq_len(nrow(df)), function(i){
    gene <- df$gene_id[i]
    # Get all values for this gene across all time points
    all_vals <- unlist(lapply(1:4, function(tp){
      cols <- tp_map$col[tp_map$tp==tp]
      if(!length(cols)) return(numeric())
      as.numeric(df[i, cols])
    }))
    all_vals <- all_vals[!is.na(all_vals)]
    
    if(length(all_vals) == 0) {
      z_scores <- rep(NA_real_, 4)
    } else {
      gene_mean <- mean(all_vals)
      gene_sd <- if(length(all_vals) > 1) sd(all_vals) else 1
      if(gene_sd == 0) gene_sd <- 1  # Avoid division by zero
      
      z_scores <- sapply(1:4, function(tp){
        cols <- tp_map$col[tp_map$tp==tp]
        if(!length(cols)) return(NA_real_)
        vals <- as.numeric(df[i, cols])
        tp_mean <- mean(vals, na.rm=TRUE)
        (tp_mean - gene_mean) / gene_sd
      })
    }
    
    tibble(gene_id=gene,
           TP1_zscore=z_scores[1], TP2_zscore=z_scores[2], TP3_zscore=z_scores[3], TP4_zscore=z_scores[4])
  })
  list_rbind(rows)
}

ortholog_path <- '../data/orthologs/ortholog_groups_three_way.csv'
apul_counts_path <- '../data/orthologs/apul-gene_count_matrix.csv'
peve_counts_path <- '../data/orthologs/peve-gene_count_matrix.csv'
ptua_counts_path <- '../data/orthologs/ptua-gene_count_matrix.csv'

# Epigenetic machinery count matrix paths
apul_epimachine_path <- 'https://gannet.fish.washington.edu/v1_web/owlshell/bu-github/timeseries_molecular/D-Apul/output/36-Apul-epimachine-counts/Apul-epimachine-expression.csv'
peve_epimachine_path <- 'https://gannet.fish.washington.edu/v1_web/owlshell/bu-github/timeseries_molecular/E-Peve/output/14-Peve-epimachine-exp/Peve-epimachine-expression.csv'
ptua_epimachine_path <- 'https://gannet.fish.washington.edu/v1_web/owlshell/bu-github/timeseries_molecular/F-Ptua/output/07-Ptua-epimachine-exp/Ptua-epimachine-expression.csv'

ortholog_data <- load_data_file(ortholog_path)
if (!nrow(ortholog_data)) message('Ortholog file missing or empty')

apul_counts <- load_data_file(apul_counts_path)
if (!nrow(apul_counts)) { message('Apul count file missing; using mock data'); genes <- unique(na.omit(ortholog_data$apul)); apul_counts <- create_mock_count_data(head(genes,50)) }
peve_counts <- load_data_file(peve_counts_path)
if (!nrow(peve_counts)) { message('Peve count file missing; using mock data'); genes <- unique(na.omit(ortholog_data$peve)); peve_counts <- create_mock_count_data(head(genes,50)) }
ptua_counts <- load_data_file(ptua_counts_path)
if (!nrow(ptua_counts)) { message('Ptua count file missing; using mock data'); genes <- unique(na.omit(ortholog_data$ptua)); ptua_counts <- create_mock_count_data(head(genes,50)) }

# Load epigenetic machinery count data
apul_epimachine <- load_data_url(apul_epimachine_path)
if (!nrow(apul_epimachine)) { message('Apul epigenetic machinery file missing; using mock data'); genes <- paste0('epi_gene_', seq_len(20)); apul_epimachine <- create_mock_count_data(genes) }
peve_epimachine <- load_data_url(peve_epimachine_path)
if (!nrow(peve_epimachine)) { message('Peve epigenetic machinery file missing; using mock data'); genes <- paste0('epi_gene_', seq_len(20)); peve_epimachine <- create_mock_count_data(genes) }
ptua_epimachine <- load_data_url(ptua_epimachine_path)
if (!nrow(ptua_epimachine)) { message('Ptua epigenetic machinery file missing; using mock data'); genes <- paste0('epi_gene_', seq_len(20)); ptua_epimachine <- create_mock_count_data(genes) }

ortholog_data <- ortholog_data |>
  mutate(
    apul_lookup = ifelse(!is.na(apul) & apul!='', sub('-T\\d+$','', apul), apul),
    peve_lookup = ifelse(!is.na(peve) & peve!='' & !grepl('^gene-', peve), paste0('gene-', peve), peve),
    ptua_lookup = ifelse(!is.na(ptua) & ptua!='' & !grepl('^gene-', ptua), paste0('gene-', ptua), ptua)
  )

apul_agg <- aggregate_gene_counts(apul_counts)
peve_agg <- aggregate_gene_counts(peve_counts)
ptua_agg <- aggregate_gene_counts(ptua_counts)

# Aggregate epigenetic machinery count data
apul_epimachine_agg <- aggregate_gene_counts(apul_epimachine)
peve_epimachine_agg <- aggregate_gene_counts(peve_epimachine)
ptua_epimachine_agg <- aggregate_gene_counts(ptua_epimachine)

# Calculate z-scores for normalized visualization
apul_zscore <- calculate_z_scores(apul_counts)
peve_zscore <- calculate_z_scores(peve_counts)
ptua_zscore <- calculate_z_scores(ptua_counts)

ortholog_groups <- if (nrow(ortholog_data)) ortholog_data$group_id else character()
names(ortholog_groups) <- if (length(ortholog_groups)) paste0(ortholog_data$group_id, ifelse(!is.na(ortholog_data$protein_name) & ortholog_data$protein_name!='', paste0(' (', ortholog_data$protein_name, ')'), '')) else character()

ortholog_json <- if (nrow(ortholog_data)) ortholog_data |>
  select(group_id, apul, peve, ptua, apul_lookup, peve_lookup, ptua_lookup, protein_name) |>
  jsonlite::toJSON(auto_unbox=TRUE) else '[]'

species_list <- list(Apul=apul_agg, Peve=peve_agg, Ptua=ptua_agg)
counts_map <- lapply(species_list, function(df){
  if (!nrow(df)) return(list())
  setNames(lapply(df$gene_id, function(g){
    row <- df[df$gene_id==g,][1,]
    list(
      mean = unname(as.numeric(row[1,c('TP1_mean','TP2_mean','TP3_mean','TP4_mean')])),
      sd   = unname(as.numeric(replace(row[1,c('TP1_sd','TP2_sd','TP3_sd','TP4_sd')], is.na(row[1,c('TP1_sd','TP2_sd','TP3_sd','TP4_sd')]), 0)))
    )
  }), df$gene_id)
})
counts_json <- jsonlite::toJSON(counts_map, auto_unbox=TRUE)

# Create epigenetic machinery data for visualization
species_epimachine_list <- list(Apul=apul_epimachine_agg, Peve=peve_epimachine_agg, Ptua=ptua_epimachine_agg)
epimachine_counts_map <- lapply(species_epimachine_list, function(df){
  if (!nrow(df)) return(list())
  setNames(lapply(df$gene_id, function(g){
    row <- df[df$gene_id==g,][1,]
    list(
      mean = unname(as.numeric(row[1,c('TP1_mean','TP2_mean','TP3_mean','TP4_mean')])),
      sd   = unname(as.numeric(replace(row[1,c('TP1_sd','TP2_sd','TP3_sd','TP4_sd')], is.na(row[1,c('TP1_sd','TP2_sd','TP3_sd','TP4_sd')]), 0)))
    )
  }), df$gene_id)
})
epimachine_counts_json <- jsonlite::toJSON(epimachine_counts_map, auto_unbox=TRUE)

# Create epigenetic machinery gene list for dropdown
epimachine_genes <- unique(c(apul_epimachine_agg$gene_id, peve_epimachine_agg$gene_id, ptua_epimachine_agg$gene_id))
names(epimachine_genes) <- epimachine_genes

# Data for visualization 2: Z-score plots with protein-identified filter
ortholog_with_protein <- ortholog_data |>
  filter(!is.na(protein_name) & protein_name != '')

ortholog_protein_groups <- if (nrow(ortholog_with_protein)) ortholog_with_protein$group_id else character()
names(ortholog_protein_groups) <- if (length(ortholog_protein_groups)) paste0(ortholog_with_protein$group_id, ' (', ortholog_with_protein$protein_name, ')') else character()

ortholog_protein_json <- if (nrow(ortholog_with_protein)) ortholog_with_protein |>
  select(group_id, apul, peve, ptua, apul_lookup, peve_lookup, ptua_lookup, protein_name) |>
  jsonlite::toJSON(auto_unbox=TRUE) else '[]'

# Create z-score data map
species_zscore_list <- list(Apul=apul_zscore, Peve=peve_zscore, Ptua=ptua_zscore)
zscore_map <- lapply(species_zscore_list, function(df){
  if (!nrow(df)) return(list())
  setNames(lapply(df$gene_id, function(g){
    row <- df[df$gene_id==g,][1,]
    unname(as.numeric(row[1,c('TP1_zscore','TP2_zscore','TP3_zscore','TP4_zscore')]))
  }), df$gene_id)
})
zscore_json <- jsonlite::toJSON(zscore_map, auto_unbox=TRUE)

# Data for visualization 3: GO slim grouping
go_slim_data <- ortholog_data |>
  filter(!is.na(goslim_names) & goslim_names != '') |>
  rowwise() |>
  mutate(
    go_terms = list(strsplit(goslim_names, ';')[[1]] |> trimws())
  ) |>
  ungroup()

# Create GO term groups
go_term_groups <- list()
if (nrow(go_slim_data) > 0) {
  all_go_terms <- unique(unlist(go_slim_data$go_terms))
  all_go_terms <- all_go_terms[!is.na(all_go_terms) & all_go_terms != '']
  
  for (term in all_go_terms) {
    matching_groups <- go_slim_data |>
      filter(sapply(go_terms, function(x) term %in% x)) |>
      pull(group_id)
    
    if (length(matching_groups) > 0) {
      go_term_groups[[term]] <- matching_groups
    }
  }
}

go_terms_list <- names(go_term_groups)
names(go_terms_list) <- paste0(go_terms_list, ' (', lengths(go_term_groups), ' groups)')

go_term_json <- jsonlite::toJSON(go_term_groups, auto_unbox=TRUE)
```



```{r}
#| echo: false
#| results: asis
if (!length(ortholog_groups)) cat('**Error: No ortholog groups available.**') else cat('Loaded **', length(ortholog_groups), '** ortholog groups.')
```

## Viewer

```{r}
#| echo: false
#| results: asis
if (length(ortholog_groups)) {
  options_html <- paste0('<option value="">-- Select an ortholog group --</option>',
    paste0('<option value="', ortholog_groups, '">', htmltools::htmlEscape(names(ortholog_groups)), '</option>', collapse=''))
  html <- htmltools::HTML(paste0(
    '<div class="card"><div class="card-body">',
    '<h5 class="card-title">Select Ortholog Group</h5>',
    '<div class="row">',
    '<div class="col-md-6">',
    '<label for="ortholog-search" class="form-label">Search (protein name, GO term, gene ID, etc.):</label>',
    '<input type="text" id="ortholog-search" class="form-control" placeholder="Type to search..." oninput="searchOrthologGroups()">',
    '</div>',
    '<div class="col-md-6">',
    '<label for="ortholog-select" class="form-label">Or select from dropdown:</label>',
    '<select id="ortholog-select" class="form-select" onchange="updateOrthoPlot()">',options_html,'</select>',
    '</div>',
    '</div>',
    '<div id="search-results" style="display:none;" class="mt-3">',
    '<h6>Search Results:</h6>',
    '<div id="search-results-list" class="list-group" style="max-height: 200px; overflow-y: auto;"></div>',
    '</div>',
    '<div id="ortholog-info" style="display:none;" class="mt-3"><div class="alert alert-info" id="group-details"></div></div>',
    '<div id="plot-container" style="display:none;" class="mt-3"><div id="ortho-plot"></div></div>',
    '<div id="no-data" style="display:none;" class="mt-3"><div class="alert alert-warning">No expression data for this group.</div></div>',
    '<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>',
  '<script>const orthologData=', ortholog_json, '; const countsData=', counts_json, ';\n',
  'function searchInText(text, query) { return text && typeof text === "string" && text.toLowerCase().includes(query.toLowerCase()); }\n',
  'function searchOrthologGroups() { const query = document.getElementById("ortholog-search").value.trim(); const resultsDiv = document.getElementById("search-results"); const resultsList = document.getElementById("search-results-list"); if (!query || query.length < 2) { resultsDiv.style.display = "none"; return; } const matches = orthologData.filter(item => searchInText(item.group_id, query) || searchInText(item.protein_name, query) || searchInText(item.apul, query) || searchInText(item.peve, query) || searchInText(item.ptua, query) || searchInText(item.go_ids, query) || searchInText(item.go_bp, query) || searchInText(item.go_cc, query) || searchInText(item.go_mf, query) || searchInText(item.goslim_names, query)); resultsList.innerHTML = ""; if (matches.length === 0) { resultsList.innerHTML = "<div class=\\"list-group-item\\">No matches found</div>"; } else { matches.slice(0, 20).forEach(item => { const displayName = item.group_id + (item.protein_name ? " (" + item.protein_name + ")" : ""); const listItem = document.createElement("div"); listItem.className = "list-group-item list-group-item-action"; listItem.style.cursor = "pointer"; listItem.innerHTML = displayName; listItem.onclick = () => { document.getElementById("ortholog-select").value = item.group_id; document.getElementById("ortholog-search").value = displayName; resultsDiv.style.display = "none"; updateOrthoPlot(); }; resultsList.appendChild(listItem); }); if (matches.length > 20) { resultsList.innerHTML += "<div class=\\"list-group-item text-muted\\">... and " + (matches.length - 20) + " more results</div>"; } } resultsDiv.style.display = "block"; }\n',
  'function getSeries(info, speciesKey){const raw=info[speciesKey.toLowerCase()]||""; const lookup=info[speciesKey.toLowerCase()+"_lookup"]||raw; const spCounts=countsData[speciesKey]; if(!spCounts) return null; if(lookup && spCounts[lookup]) return spCounts[lookup]; if(raw && spCounts[raw]) return spCounts[raw]; return null;}\n',
  'function updateOrthoPlot(){const sel=document.getElementById("ortholog-select").value; if(!sel){["ortholog-info","plot-container","no-data"].forEach(id=>document.getElementById(id).style.display="none");return;} const info=orthologData.find(o=>o.group_id===sel); const detailEl=document.getElementById("group-details"); if(info){detailEl.innerHTML=`<strong>Group:</strong> ${sel}<br><strong>Apul:</strong> ${info.apul||"N/A"}<br><strong>Peve:</strong> ${info.peve||"N/A"}<br><strong>Ptua:</strong> ${info.ptua||"N/A"}<br><strong>Protein:</strong> ${info.protein_name||"N/A"}<br><em>Values show mean ± SD</em>`; document.getElementById("ortholog-info").style.display="block";} const species=["Apul","Peve","Ptua"]; const names=["A. pulchra","P. evermanni","P. tuahiniensis"]; const colors=["#1f77b4","#2ca02c","#d62728"]; const traces=[]; let has=false; species.forEach((sp,i)=>{const s=getSeries(info, sp); if(s && s.mean){has=true; const y=s.mean; const sd=s.sd || [0,0,0,0]; traces.push({x:[1,2,3,4], y:y, mode:"lines+markers", name:names[i], line:{width:3,color:colors[i]}, marker:{size:8}, error_y:{type:"data", array:sd, visible:true, thickness:1, width:0}});} }); if(has){Plotly.newPlot("ortho-plot", traces,{title:`Expression (Mean ± SD) - ${sel}`,xaxis:{title:"Time Point", tickvals:[1,2,3,4], ticktext:["TP1","TP2","TP3","TP4"]}, yaxis:{title:"Mean Read Count"}, height:430}); document.getElementById("plot-container").style.display="block"; document.getElementById("no-data").style.display="none";} else {document.getElementById("plot-container").style.display="none"; document.getElementById("no-data").style.display="block";}}',
    '</script></div></div>'
  ))
  print(html)
}
```

```{asis}
<noscript><div class="alert alert-danger">JavaScript required for the interactive plot.</div></noscript>
```

## Epigenetic Machinery Expression

```{r}
#| echo: false
#| results: asis
if (length(epimachine_genes)) {
  epimachine_options_html <- paste0('<option value="">-- Select an epigenetic machinery gene --</option>',
    paste0('<option value="', epimachine_genes, '">', htmltools::htmlEscape(names(epimachine_genes)), '</option>', collapse=''))
  epimachine_html <- htmltools::HTML(paste0(
    '<div class="card"><div class="card-body">',
    '<h5 class="card-title">Select Epigenetic Machinery Gene</h5>',
    '<div class="row">',
    '<div class="col-md-6">',
    '<label for="epimachine-search" class="form-label">Search gene ID:</label>',
    '<input type="text" id="epimachine-search" class="form-control" placeholder="Type to search genes..." oninput="searchEpimachineGenes()">',
    '</div>',
    '<div class="col-md-6">',
    '<label for="epimachine-select" class="form-label">Or select from dropdown:</label>',
    '<select id="epimachine-select" class="form-select" onchange="updateEpimachinePlot()">',epimachine_options_html,'</select>',
    '</div>',
    '</div>',
    '<div id="search-results-epimachine" style="display:none;" class="mt-3">',
    '<h6>Search Results:</h6>',
    '<div id="search-results-list-epimachine" class="list-group" style="max-height: 200px; overflow-y: auto;"></div>',
    '</div>',
    '<div id="epimachine-info" style="display:none;" class="mt-3"><div class="alert alert-info" id="epimachine-details"></div></div>',
    '<div id="plot-container-epimachine" style="display:none;" class="mt-3"><div id="epimachine-plot"></div></div>',
    '<div id="no-data-epimachine" style="display:none;" class="mt-3"><div class="alert alert-warning">No expression data for this gene.</div></div>',
  '<script>const epimachineCountsData=', epimachine_counts_json, ';\n',
  'function searchEpimachineGenes() { const query = document.getElementById("epimachine-search").value.trim(); const resultsDiv = document.getElementById("search-results-epimachine"); const resultsList = document.getElementById("search-results-list-epimachine"); if (!query || query.length < 2) { resultsDiv.style.display = "none"; return; } const genes = Object.keys(epimachineCountsData.Apul || {}).concat(Object.keys(epimachineCountsData.Peve || {})).concat(Object.keys(epimachineCountsData.Ptua || {})); const uniqueGenes = [...new Set(genes)]; const matches = uniqueGenes.filter(gene => gene.toLowerCase().includes(query.toLowerCase())); resultsList.innerHTML = ""; if (matches.length === 0) { resultsList.innerHTML = "<div class=\\"list-group-item\\">No matches found</div>"; } else { matches.slice(0, 20).forEach(gene => { const listItem = document.createElement("div"); listItem.className = "list-group-item list-group-item-action"; listItem.style.cursor = "pointer"; listItem.innerHTML = gene; listItem.onclick = () => { document.getElementById("epimachine-select").value = gene; document.getElementById("epimachine-search").value = gene; resultsDiv.style.display = "none"; updateEpimachinePlot(); }; resultsList.appendChild(listItem); }); if (matches.length > 20) { resultsList.innerHTML += "<div class=\\"list-group-item text-muted\\">... and " + (matches.length - 20) + " more results</div>"; } } resultsDiv.style.display = "block"; }\n',
  'function getEpimachineSeries(geneId, speciesKey){const spCounts=epimachineCountsData[speciesKey]; if(!spCounts) return null; if(spCounts[geneId]) return spCounts[geneId]; return null;}\n',
  'function updateEpimachinePlot(){const sel=document.getElementById("epimachine-select").value; if(!sel){["epimachine-info","plot-container-epimachine","no-data-epimachine"].forEach(id=>document.getElementById(id).style.display="none");return;} const detailEl=document.getElementById("epimachine-details"); detailEl.innerHTML=`<strong>Gene:</strong> ${sel}<br><em>Epigenetic machinery gene expression across time points<br>Values show mean ± SD</em>`; document.getElementById("epimachine-info").style.display="block"; const species=["Apul","Peve","Ptua"]; const names=["A. pulchra","P. evermanni","P. tuahiniensis"]; const colors=["#1f77b4","#2ca02c","#d62728"]; const traces=[]; let has=false; species.forEach((sp,i)=>{const s=getEpimachineSeries(sel, sp); if(s && s.mean){has=true; const y=s.mean; const sd=s.sd || [0,0,0,0]; traces.push({x:[1,2,3,4], y:y, mode:"lines+markers", name:names[i], line:{width:3,color:colors[i]}, marker:{size:8}, error_y:{type:"data", array:sd, visible:true, thickness:1, width:0}});} }); if(has){Plotly.newPlot("epimachine-plot", traces,{title:`Epigenetic Machinery Expression (Mean ± SD) - ${sel}`,xaxis:{title:"Time Point", tickvals:[1,2,3,4], ticktext:["TP1","TP2","TP3","TP4"]}, yaxis:{title:"Mean Read Count"}, height:430}); document.getElementById("plot-container-epimachine").style.display="block"; document.getElementById("no-data-epimachine").style.display="none";} else {document.getElementById("plot-container-epimachine").style.display="none"; document.getElementById("no-data-epimachine").style.display="block";}}',
    '</script></div></div>'
  ))
  print(epimachine_html)
} else {
  cat('**No epigenetic machinery genes available.**')
}
```

```{asis}
<noscript><div class="alert alert-danger">JavaScript required for the interactive plot.</div></noscript>
```

## Z-Score Normalized Expression (Protein-Identified Orthologs Only)

```{r}
#| echo: false
#| results: asis
if (length(ortholog_protein_groups)) {
  options_html2 <- paste0('<option value="">-- Select an ortholog group --</option>',
    paste0('<option value="', ortholog_protein_groups, '">', htmltools::htmlEscape(names(ortholog_protein_groups)), '</option>', collapse=''))
  html2 <- htmltools::HTML(paste0(
    '<div class="card"><div class="card-body">',
    '<h5 class="card-title">Select Ortholog Group (Z-Score Normalized)</h5>',
    '<div class="row">',
    '<div class="col-md-6">',
    '<label for="ortholog-search-zscore" class="form-label">Search (protein name, GO term, gene ID, etc.):</label>',
    '<input type="text" id="ortholog-search-zscore" class="form-control" placeholder="Type to search..." oninput="searchOrthologGroupsZscore()">',
    '</div>',
    '<div class="col-md-6">',
    '<label for="ortholog-select-zscore" class="form-label">Or select from dropdown:</label>',
    '<select id="ortholog-select-zscore" class="form-select" onchange="updateZscorePlot()">',options_html2,'</select>',
    '</div>',
    '</div>',
    '<div id="search-results-zscore" style="display:none;" class="mt-3">',
    '<h6>Search Results:</h6>',
    '<div id="search-results-list-zscore" class="list-group" style="max-height: 200px; overflow-y: auto;"></div>',
    '</div>',
    '<div id="ortholog-info-zscore" style="display:none;" class="mt-3"><div class="alert alert-info" id="group-details-zscore"></div></div>',
    '<div id="plot-container-zscore" style="display:none;" class="mt-3"><div id="ortho-plot-zscore"></div></div>',
    '<div id="no-data-zscore" style="display:none;" class="mt-3"><div class="alert alert-warning">No expression data for this group.</div></div>',
    '<script>const orthologProteinData=', ortholog_protein_json, '; const zscoreData=', zscore_json, ';\n',
    'function searchOrthologGroupsZscore() { const query = document.getElementById("ortholog-search-zscore").value.trim(); const resultsDiv = document.getElementById("search-results-zscore"); const resultsList = document.getElementById("search-results-list-zscore"); if (!query || query.length < 2) { resultsDiv.style.display = "none"; return; } const matches = orthologProteinData.filter(item => searchInText(item.group_id, query) || searchInText(item.protein_name, query) || searchInText(item.apul, query) || searchInText(item.peve, query) || searchInText(item.ptua, query) || searchInText(item.go_ids, query) || searchInText(item.go_bp, query) || searchInText(item.go_cc, query) || searchInText(item.go_mf, query) || searchInText(item.goslim_names, query)); resultsList.innerHTML = ""; if (matches.length === 0) { resultsList.innerHTML = "<div class=\\"list-group-item\\">No matches found</div>"; } else { matches.slice(0, 20).forEach(item => { const displayName = item.group_id + " (" + item.protein_name + ")"; const listItem = document.createElement("div"); listItem.className = "list-group-item list-group-item-action"; listItem.style.cursor = "pointer"; listItem.innerHTML = displayName; listItem.onclick = () => { document.getElementById("ortholog-select-zscore").value = item.group_id; document.getElementById("ortholog-search-zscore").value = displayName; resultsDiv.style.display = "none"; updateZscorePlot(); }; resultsList.appendChild(listItem); }); if (matches.length > 20) { resultsList.innerHTML += "<div class=\\"list-group-item text-muted\\">... and " + (matches.length - 20) + " more results</div>"; } } resultsDiv.style.display = "block"; }\n',
    'function getZscoreSeries(info, speciesKey){const raw=info[speciesKey.toLowerCase()]||""; const lookup=info[speciesKey.toLowerCase()+"_lookup"]||raw; const spZscore=zscoreData[speciesKey]; if(!spZscore) return null; if(lookup && spZscore[lookup]) return spZscore[lookup]; if(raw && spZscore[raw]) return spZscore[raw]; return null;}\n',
    'function updateZscorePlot(){const sel=document.getElementById("ortholog-select-zscore").value; if(!sel){["ortholog-info-zscore","plot-container-zscore","no-data-zscore"].forEach(id=>document.getElementById(id).style.display="none");return;} const info=orthologProteinData.find(o=>o.group_id===sel); const detailEl=document.getElementById("group-details-zscore"); if(info){detailEl.innerHTML=`<strong>Group:</strong> ${sel}<br><strong>Apul:</strong> ${info.apul||"N/A"}<br><strong>Peve:</strong> ${info.peve||"N/A"}<br><strong>Ptua:</strong> ${info.ptua||"N/A"}<br><strong>Protein:</strong> ${info.protein_name||"N/A"}<br><em>Values show Z-scores (normalized)</em>`; document.getElementById("ortholog-info-zscore").style.display="block";} const species=["Apul","Peve","Ptua"]; const names=["A. pulchra","P. evermanni","P. tuahiniensis"]; const colors=["#1f77b4","#2ca02c","#d62728"]; const traces=[]; let has=false; species.forEach((sp,i)=>{const s=getZscoreSeries(info, sp); if(s && s.length==4 && !s.every(v=>isNaN(v))){has=true; traces.push({x:[1,2,3,4], y:s, mode:"lines+markers", name:names[i], line:{width:3,color:colors[i]}, marker:{size:8}});} }); if(has){Plotly.newPlot("ortho-plot-zscore", traces,{title:`Z-Score Expression - ${sel}`,xaxis:{title:"Time Point", tickvals:[1,2,3,4], ticktext:["TP1","TP2","TP3","TP4"]}, yaxis:{title:"Z-Score"}, height:430}); document.getElementById("plot-container-zscore").style.display="block"; document.getElementById("no-data-zscore").style.display="none";} else {document.getElementById("plot-container-zscore").style.display="none"; document.getElementById("no-data-zscore").style.display="block";}}',
    '</script></div></div>'
  ))
  print(html2)
} else {
  cat('**No ortholog groups with protein identification available.**')
}
```

## GO Slim Groups (Z-Score Normalized)

```{r}
#| echo: false
#| results: asis
if (length(go_terms_list)) {
  options_html3 <- paste0('<option value="">-- Select a GO slim term --</option>',
    paste0('<option value="', htmltools::htmlEscape(go_terms_list), '">', htmltools::htmlEscape(names(go_terms_list)), '</option>', collapse=''))
  html3 <- htmltools::HTML(paste0(
    '<div class="card"><div class="card-body">',
    '<h5 class="card-title">Select GO Slim Term</h5>',
    '<div class="row">',
    '<div class="col-md-6">',
    '<label for="go-term-search" class="form-label">Search GO terms:</label>',
    '<input type="text" id="go-term-search" class="form-control" placeholder="Type to search GO terms..." oninput="searchGoTerms()">',
    '</div>',
    '<div class="col-md-6">',
    '<label for="go-term-select" class="form-label">Or select from dropdown:</label>',
    '<select id="go-term-select" class="form-select" onchange="updateGoTermPlot()">',options_html3,'</select>',
    '</div>',
    '</div>',
    '<div id="search-results-go" style="display:none;" class="mt-3">',
    '<h6>Search Results:</h6>',
    '<div id="search-results-list-go" class="list-group" style="max-height: 200px; overflow-y: auto;"></div>',
    '</div>',
    '<div id="go-term-info" style="display:none;" class="mt-3"><div class="alert alert-info" id="go-term-details"></div></div>',
    '<div id="plot-container-go" style="display:none;" class="mt-3"><div id="ortho-plot-go"></div></div>',
    '<div id="no-data-go" style="display:none;" class="mt-3"><div class="alert alert-warning">No GO slim terms available.</div></div>',
    '<script>const goTermGroups=', go_term_json, '; const goOrthologData=', ortholog_json, '; const goZscoreData=', zscore_json, ';\n',
    'function searchGoTerms() { const query = document.getElementById("go-term-search").value.trim(); const resultsDiv = document.getElementById("search-results-go"); const resultsList = document.getElementById("search-results-list-go"); if (!query || query.length < 2) { resultsDiv.style.display = "none"; return; } const goTermsArray = Object.keys(goTermGroups); const matches = goTermsArray.filter(term => searchInText(term, query)); resultsList.innerHTML = ""; if (matches.length === 0) { resultsList.innerHTML = "<div class=\\"list-group-item\\">No matches found</div>"; } else { matches.slice(0, 20).forEach(term => { const displayName = term + " (" + goTermGroups[term].length + " groups)"; const listItem = document.createElement("div"); listItem.className = "list-group-item list-group-item-action"; listItem.style.cursor = "pointer"; listItem.innerHTML = displayName; listItem.onclick = () => { document.getElementById("go-term-select").value = term; document.getElementById("go-term-search").value = displayName; resultsDiv.style.display = "none"; updateGoTermPlot(); }; resultsList.appendChild(listItem); }); if (matches.length > 20) { resultsList.innerHTML += "<div class=\\"list-group-item text-muted\\">... and " + (matches.length - 20) + " more results</div>"; } } resultsDiv.style.display = "block"; }\n',
    'function getGoZscoreSeries(info, speciesKey){const raw=info[speciesKey.toLowerCase()]||""; const lookup=info[speciesKey.toLowerCase()+"_lookup"]||raw; const spZscore=goZscoreData[speciesKey]; if(!spZscore) return null; if(lookup && spZscore[lookup]) return spZscore[lookup]; if(raw && spZscore[raw]) return spZscore[raw]; return null;}\n',
    'function updateGoTermPlot(){const sel=document.getElementById("go-term-select").value; if(!sel){["go-term-info","plot-container-go","no-data-go"].forEach(id=>document.getElementById(id).style.display="none");return;} const groupIds=goTermGroups[sel]; if(!groupIds || !groupIds.length){document.getElementById("no-data-go").style.display="block"; return;} const detailEl=document.getElementById("go-term-details"); detailEl.innerHTML=`<strong>GO Term:</strong> ${sel}<br><strong>Number of Groups:</strong> ${groupIds.length}<br><em>Showing heatmap of Z-score expression</em>`; document.getElementById("go-term-info").style.display="block"; const species=["Apul","Peve","Ptua"]; const names=["A. pulchra","P. evermanni","P. tuahiniensis"]; let hasData=false; const zMatrix=[]; const yLabels=[]; species.forEach((sp,spIdx)=>{groupIds.forEach((groupId)=>{const info=goOrthologData.find(o=>o.group_id===groupId); if(info){const s=getGoZscoreSeries(info,sp); if(s && s.length===4 && !s.every(v=>isNaN(v))){hasData=true; zMatrix.push(s); yLabels.push(`${names[spIdx]} - ${groupId}`);} } }); }); if(hasData && zMatrix.length>0){const heatmapTrace={z:zMatrix, x:["TP1","TP2","TP3","TP4"], y:yLabels, type:"heatmap", colorscale:"RdBu_r", showscale:true, hoverongaps:false, hovertemplate:"Group: %{y}<br>Time: %{x}<br>Z-score: %{z:.2f}<extra></extra>", colorbar:{title:"Z-score", titleside:"right"}}; const layout={title:`GO Groups Z-Score Heatmap - ${sel}`, xaxis:{title:"Time Point", side:"bottom"}, yaxis:{title:"Species - Group ID", autorange:"reversed"}, height:Math.max(400,yLabels.length*20+150), margin:{l:200,r:100,t:60,b:60}}; Plotly.newPlot("ortho-plot-go",[heatmapTrace],layout); document.getElementById("plot-container-go").style.display="block"; document.getElementById("no-data-go").style.display="none";} else {document.getElementById("plot-container-go").style.display="none"; document.getElementById("no-data-go").style.display="block";}}',
    '</script></div></div>'
  ))
  print(html3)
} else {
  cat('**No GO slim terms available.**')
}
```


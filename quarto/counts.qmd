---
title: "Expression Values"
description: "Count Matrices"
format:
  html:
    code-copy: true
    toc: true
    toc-location: right
    toc-expand: true
editor: visual
execute:
  echo: false
  warning: false
  message: false
---

```{r setup, include=FALSE}
library(tidyverse)
library(DT)
library(readxl)
library(plotly)
library(readr)
library(dplyr)
library(tibble)
library(knitr)
library(gt)
library(htmltools)
```

```{r, cache=TRUE, include=FALSE}

# Define key paths and tool directories

Apul_gene_url <- "https://gannet.fish.washington.edu/gitrepos/urol-e5/timeseries_molecular/D-Apul/output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv"

Apul_mirna_url <- "https://raw.githubusercontent.com/urol-e5/timeseries_molecular/refs/heads/main/M-multi-species/output/10-format-miRNA-counts/Apul_miRNA_counts_formatted.txt"

Apul_lncRNA_url <- "https://gannet.fish.washington.edu/v1_web/owlshell/bu-github/timeseries_molecular/D-Apul/output/33-Apul-lncRNA-matrix/Apul_lncRNA_counts_filtered.txt"

Apul_mCpG_url <- "https://gannet.fish.washington.edu/metacarcinus/E5/20250821_meth_Apul/merged-WGBS-CpG-counts_filtered.csv"



Peve_gene_url <- "https://gannet.fish.washington.edu/gitrepos/urol-e5/timeseries_molecular/E-Peve/output/02.20-E-Peve-RNAseq-alignment-HiSat2/peve-gene_count_matrix.csv"

Peve_mirna_url <- "https://raw.githubusercontent.com/urol-e5/timeseries_molecular/refs/heads/main/M-multi-species/output/10-format-miRNA-counts/Peve_miRNA_counts_formatted.txt"

Peve_lncRNA_url <- "https://gannet.fish.washington.edu/v1_web/owlshell/bu-github/timeseries_molecular/E-Peve/output/13-Peve-lncRNA-matrix/Peve_lncRNA_counts_filtered.txt"

Peve_mCpG_url <- "https://gannet.fish.washington.edu/metacarcinus/E5/Pevermanni/20250821_meth_Peve/merged-WGBS-CpG-counts_filtered.csv"



Ptuh_gene_url <- "https://gannet.fish.washington.edu/gitrepos/urol-e5/timeseries_molecular/F-Ptua/output/02.20-F-Ptua-RNAseq-alignment-HiSat2/ptua-gene_count_matrix.csv"

Ptuh_mirna_url <- "https://raw.githubusercontent.com/urol-e5/timeseries_molecular/refs/heads/main/M-multi-species/output/10-format-miRNA-counts/Ptuh_miRNA_counts_formatted.txt"

Ptuh_lncRNA_url <- "https://raw.githubusercontent.com/urol-e5/timeseries_molecular/refs/heads/main/F-Ptua/output/06-Ptua-lncRNA-discovery/lncRNA_counts.clean.filtered.txt"

Ptuh_mCpG_url <- "https://gannet.fish.washington.edu/metacarcinus/E5/Ptuahiniensis/20250821_meth_Ptua/merged-WGBS-CpG-counts_filtered.csv"


# read in 


Apul_gene <- read_csv(Apul_gene_url)
Apul_mirna <- read_delim(Apul_mirna_url, delim = "\t", col_names = TRUE)
Apul_lncRNA <- read_delim(Apul_lncRNA_url, delim = "\t", col_names = TRUE, skip = 7)
Apul_mCpG <- read_csv(Apul_mCpG_url)


Peve_gene <- read_csv(Peve_gene_url)
Peve_mirna <- read_delim(Peve_mirna_url, delim = "\t", col_names = TRUE)
Peve_lncRNA <- read_delim(Peve_lncRNA_url, delim = "\t", col_names = TRUE, skip = 7)
Peve_mCpG <- read_csv(Peve_mCpG_url)

Ptuh_gene <- read_csv(Ptuh_gene_url)
Ptuh_mirna <- read_delim(Ptuh_mirna_url, delim = "\t", col_names = TRUE)
Ptuh_lncRNA <- read_delim(Ptuh_lncRNA_url, delim = "\t", col_names = TRUE)
Ptuh_mCpG <- read_csv(Ptuh_mCpG_url)


```


| Species | Gene | miRNA | lncRNA | mCpG |
|---------------|---------------|---------------|---------------|---------------|
| *Acropora pulchra* | **`r nrow(Apul_gene)`** | **`r nrow(Apul_mirna)`** | **`r nrow(Apul_lncRNA)`** | **`r nrow(Apul_mCpG)`** |
|  *Porites evermanni* | **`r nrow(Peve_gene)`** | **`r nrow(Peve_mirna)`** | **`r nrow(Peve_lncRNA)`** | **`r nrow(Peve_mCpG)`** |
| *Pocillopora tuahiniensis* | **`r nrow(Ptuh_gene)`** | **`r nrow(Ptuh_mirna)`** | **`r nrow(Ptuh_lncRNA)`** | **`r nrow(Ptuh_mCpG)`** |

: Feature Counts

::: callout-tip
## ConTra

If you are excited about analyzing this type of data in contextual manner check out [ConTra - Contextual Transcriptome Regulation Analysis](https://github.com/sr320/ConTra)
:::

## About Computational Pipelines

::: panel-tabset
## Genes

This workflow aligns trimmed RNA-seq reads to a reference genome using HISAT2, followed by transcript assembly and quantification with StringTie, and culminates in the generation of count matrices for downstream expression analysis. Individual sample directories contain BAMs, indexes, GTFs, Ballgown-formatted tables, and alignment statistics, while a MultiQC report aggregates overall alignment quality. The workflow then merges sorted BAMs into a single dataset, compiles a unified transcript GTF from individual assemblies, and uses prepDE to produce gene- and transcript-level count matrices compatible with DESeq2. 

## miRNA

ShortStack ? Kathleen

## lncRNA

Workflow builds a splice-aware HISAT2 index from the GTF (exons + splice sites), and aligns all samples. Per-sample transcript assemblies are generated with StringTie and merged into a unified GTF, which is then annotated with gffcompare. Putative lncRNAs are filtered from the merged annotations by biotype/class codes (u/x/o/i) and minimum length (\>200 nt), sequences are extracted with bedtools, and coding potential is screened with CPC2 to retain noncoding transcripts. The surviving transcripts are converted into a clean BED/GTF set with unique lncRNA\_### IDs, deduplicated, sanity-checked (coordinates/lengths), and summarized. Finally, featureCounts quantifies lncRNA features across all BAMs, column names are cleaned, and a filtered count matrix is produced, removing features with \<10 counts in \>50% of samples.

## mCpG

For EM-seq analysis Bismark methylation coverage (.cov) files are unified into CpG methylation matrices. First, .cov.gz are filtered for CpG sites with ≥10× coverage and converts them into bedgraph files. Each bedgraph is reformatted into a simplified two-column \_processed.txt file containing unique CpG IDs and percent methylation values. A Python script then merges all \_processed.txt files into a single matrix, with CpG loci as rows and samples as columns. Only loci where 10x coverage is present in all samples are retained.
:::

::: callout-warning
## Sample ID formatting

Note currently we have some inconsistency in sample IDs across data types.
:::

# *Acropora pulchra*

## Gene Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Apul_gene_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Apul_gene_count_matrix.csv",
    "Download Gene Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Apul_gene_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
Apul_gene |>
  slice_head(n = 4) |>
  gt()
```

## miRNA Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Apul_mirna_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Apul_miRNA_counts.txt",
    "Download miRNA Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Apul_mirna_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
Apul_mirna |>
  slice_head(n = 4) |>
  gt()
```

## lncRNA Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Apul_lncRNA_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Apul_lncRNA_counts.txt",
    "Download lncRNA Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Apul_lncRNA_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
#| tbl-cap: "Apul_lncRNA (first 10 rows with row numbers)"
Apul_lncRNA |>
  slice_head(n = 4) |>
  gt()
```

## mCpG Percentage

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Apul_mCpG_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Apul_mCpG_counts.csv",
    "Download mCpG Percentage"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Apul_mCpG_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
#| tbl-cap: "Apul_mCpG (first 10 rows with row numbers)"
Apul_mCpG |>
  slice_head(n = 4) |>
  gt()
```

# *Porites evermanni*

## Gene Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Peve_gene_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Peve_gene_count_matrix.csv",
    "Download Gene Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Peve_gene_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
Peve_gene |>
  slice_head(n = 4) |>
  gt()
```

## miRNA Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Peve_mirna_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Peve_miRNA_counts.txt",
    "Download miRNA Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Peve_mirna_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
Peve_mirna |>
  slice_head(n = 4) |>
  gt()
```

## lncRNA Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Peve_lncRNA_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Peve_lncRNA_counts.txt",
    "Download lncRNA Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Peve_lncRNA_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
#| tbl-cap: "Peve_lncRNA (first 10 rows with row numbers)"
Peve_lncRNA |>
  slice_head(n = 4) |>
  gt()
```

## mCpG Percentage

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Peve_mCpG_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Peve_mCpG_counts.csv",
    "Download mCpG Percentage"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Peve_mCpG_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
#| tbl-cap: "Peve_mCpG (first 10 rows with row numbers)"
Peve_mCpG |>
  slice_head(n = 4) |>
  gt()
```

# *Pocillopora tuahiniensis*

## Gene Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Ptuh_gene_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Ptuh_gene_count_matrix.csv",
    "Download Gene Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Ptuh_gene_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
Ptuh_gene |>
  slice_head(n = 4) |>
  gt()
```

## miRNA Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Ptuh_mirna_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Ptuh_miRNA_counts.txt",
    "Download miRNA Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Ptuh_mirna_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
Ptuh_mirna |>
  slice_head(n = 4) |>
  gt()
```

## lncRNA Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Ptuh_lncRNA_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Ptuh_lncRNA_count_matrix.csv",
    "Download lncRNA Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Ptuh_lncRNA_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
#| tbl-cap: "Ptuh_lncRNA (first 10 rows with row numbers)"
Ptuh_lncRNA |>
  slice_head(n = 4) |>
  gt()
```

## mCpG Percentage

```{r}
#| echo: false
#| results: asis

cat(as.character(
  tags$a(
    href = Ptuh_mCpG_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Ptuh_mCpG_matrix.csv",
    "Download mCpG Percentage"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Ptuh_mCpG_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
#| tbl-cap: "Ptuh_mCpG (first 10 rows with row numbers)"
Ptuh_mCpG |>
  slice_head(n = 4) |>
  gt()
```

# Quality Control Visualizations

## Sample Count Variation Analysis

This section provides visual quality control analysis showing sample count variation across species and feature types, as well as outlier detection within each count matrix.

```{r qc-setup}
#| echo: false
#| warning: false
#| message: false

# Function to safely count samples in a dataset
safe_sample_count <- function(df) {
  if (is.null(df) || !is.data.frame(df) || nrow(df) == 0) {
    return(0)
  }
  # Count columns that contain "TP" (timepoint indicators)
  sample_cols <- grep("TP", colnames(df), value = TRUE)
  return(length(sample_cols))
}

# Create sample count summary using the refactored data structure
sample_summary_data <- data.frame()

for (species_code in names(data_urls)) {
  species_info <- data_urls[[species_code]]
  
  for (data_type in c("gene", "mirna", "lncRNA", "mCpG")) {
    df <- all_data[[species_code]][[data_type]]
    sample_count <- safe_sample_count(df)
    
    # Create proper display names
    data_type_display <- switch(data_type,
      "gene" = "Gene",
      "mirna" = "miRNA", 
      "lncRNA" = "lncRNA",
      "mCpG" = "mCpG"
    )
    
    sample_summary_data <- rbind(sample_summary_data, data.frame(
      Species = species_info$species_name,
      Feature_Type = data_type_display,
      Sample_Count = sample_count,
      Species_Code = species_code,
      Data_Type = data_type,
      stringsAsFactors = FALSE
    ))
  }
}

# Convert to factors for better plotting (if data exists)
if (nrow(sample_summary_data) > 0) {
  # Get unique species names in the order they appear in the config
  species_order <- sapply(names(data_urls), function(x) data_urls[[x]]$species_name)
  
  sample_summary_data$Species <- factor(sample_summary_data$Species, 
                                       levels = species_order)
  sample_summary_data$Feature_Type <- factor(sample_summary_data$Feature_Type, 
                                           levels = c("Gene", "miRNA", "lncRNA", "mCpG"))
}
```

### Sample Count Distribution Across Species and Feature Types

```{r qc-sample-plot}
#| fig-cap: "Sample counts vary significantly across species and feature types. Gene expression matrices consistently have the highest sample representation, while mCpG methylation data shows the most variation between species."
#| fig-width: 10
#| fig-height: 6

# Only create plot if we have data
if (nrow(sample_summary_data) > 0 && any(sample_summary_data$Sample_Count > 0)) {
  
  library(ggplot2)
  
  # Create a grouped bar plot
  p1 <- ggplot(sample_summary_data, aes(x = Feature_Type, y = Sample_Count, fill = Species)) +
    geom_bar(stat = "identity", position = "dodge", alpha = 0.8) +
    geom_text(aes(label = Sample_Count), 
              position = position_dodge(width = 0.9), 
              vjust = -0.3, size = 3) +
    scale_fill_manual(values = c("#E31A1C", "#1F78B4", "#33A02C")) +
    labs(
      title = "Sample Count Variation Across Species and Feature Types",
      subtitle = "Showing number of samples in each count matrix",
      x = "Feature Type",
      y = "Number of Samples",
      fill = "Species"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      plot.subtitle = element_text(size = 12),
      axis.title = element_text(size = 11),
      legend.position = "bottom",
      panel.grid.minor = element_blank()
    ) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.1)))
  
  print(p1)
  
} else {
  cat("No sample data available for visualization.\n")
}
```

### Sample Count Summary Table

```{r qc-sample-table}
#| tbl-cap: "Summary of sample counts across all matrices"

# Only create table if we have data
if (nrow(sample_summary_data) > 0) {
  # Create a pivot table for better display
  sample_pivot <- sample_summary_data %>%
    select(Species, Feature_Type, Sample_Count) %>%
    tidyr::pivot_wider(names_from = Feature_Type, values_from = Sample_Count) %>%
    rowwise() %>%
    mutate(Total = sum(c_across(c("Gene", "miRNA", "lncRNA", "mCpG")), na.rm = TRUE)) %>%
    ungroup()
  
  knitr::kable(sample_pivot, 
               caption = "Sample Counts by Species and Feature Type",
               col.names = c("Species", "Gene", "miRNA", "lncRNA", "mCpG", "Total"))
} else {
  cat("No sample data available for summary table.\n")
}
```

## Feature Outlier Detection

This analysis identifies features (genes, miRNAs, lncRNAs, or CpG sites) that show unusual count patterns compared to the rest of the features in each matrix.

```{r qc-outlier-setup}
#| echo: false
#| warning: false
#| message: false

# Function to detect outliers using IQR method with enhanced error handling
detect_outliers <- function(data_matrix, matrix_name) {
  # Validate input
  if (is.null(data_matrix) || !is.data.frame(data_matrix) || nrow(data_matrix) == 0) {
    return(list(
      summary = data.frame(
        Matrix = matrix_name,
        Total_Features = 0,
        Low_Outliers = 0,
        High_Outliers = 0,
        Outlier_Percentage = 0,
        Median_Count = 0,
        Q1_Count = 0,
        Q3_Count = 0
      ),
      feature_totals = numeric(0),
      outlier_indices = integer(0),
      thresholds = c(lower = 0, upper = 0)
    ))
  }
  
  # Find sample columns (those containing "TP")
  sample_cols <- grep("TP", colnames(data_matrix), value = TRUE)
  
  if (length(sample_cols) == 0) {
    # If no TP columns, use all numeric columns except the first one
    numeric_cols <- sapply(data_matrix, is.numeric)
    sample_cols <- names(data_matrix)[numeric_cols]
    if (length(sample_cols) > 1) {
      sample_cols <- sample_cols[-1]  # Remove first column (likely ID column)
    }
  }
  
  if (length(sample_cols) == 0) {
    return(list(
      summary = data.frame(
        Matrix = matrix_name,
        Total_Features = nrow(data_matrix),
        Low_Outliers = 0,
        High_Outliers = 0,
        Outlier_Percentage = 0,
        Median_Count = 0,
        Q1_Count = 0,
        Q3_Count = 0
      ),
      feature_totals = numeric(0),
      outlier_indices = integer(0),
      thresholds = c(lower = 0, upper = 0)
    ))
  }
  
  # Calculate row sums (total counts per feature) using only sample columns
  feature_totals <- rowSums(data_matrix[, sample_cols, drop = FALSE], na.rm = TRUE)
  
  # Calculate quartiles and IQR
  Q1 <- quantile(feature_totals, 0.25, na.rm = TRUE)
  Q3 <- quantile(feature_totals, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  
  # Define outlier thresholds
  lower_threshold <- Q1 - 1.5 * IQR
  upper_threshold <- Q3 + 1.5 * IQR
  
  # Identify outliers
  outlier_indices <- which(feature_totals < lower_threshold | feature_totals > upper_threshold)
  
  # Create summary
  outlier_summary <- data.frame(
    Matrix = matrix_name,
    Total_Features = nrow(data_matrix),
    Low_Outliers = sum(feature_totals < lower_threshold, na.rm = TRUE),
    High_Outliers = sum(feature_totals > upper_threshold, na.rm = TRUE),
    Outlier_Percentage = round((length(outlier_indices) / nrow(data_matrix)) * 100, 2),
    Median_Count = round(median(feature_totals, na.rm = TRUE), 2),
    Q1_Count = round(Q1, 2),
    Q3_Count = round(Q3, 2)
  )
  
  return(list(
    summary = outlier_summary,
    feature_totals = feature_totals,
    outlier_indices = outlier_indices,
    thresholds = c(lower = lower_threshold, upper = upper_threshold)
  ))
}

# Analyze all matrices using the new data structure
outlier_results <- list()
all_outlier_summaries <- data.frame()

for (species_code in names(data_urls)) {
  for (data_type in c("gene", "mirna", "lncRNA", "mCpG")) {
    df <- all_data[[species_code]][[data_type]]
    matrix_name <- paste0(species_code, "_", data_type)
    
    # Perform outlier analysis
    result <- detect_outliers(df, matrix_name)
    outlier_results[[matrix_name]] <- result
    
    # Add to summary
    all_outlier_summaries <- rbind(all_outlier_summaries, result$summary)
  }
}
```

### Outlier Detection Summary

```{r qc-outlier-table}
#| tbl-cap: "Outlier features detected in each count matrix using IQR method (1.5×IQR beyond Q1/Q3)"

# Only display table if we have results
if (nrow(all_outlier_summaries) > 0) {
  knitr::kable(all_outlier_summaries, 
               caption = "Feature Outlier Detection Results",
               col.names = c("Count Matrix", "Total Features", "Low Outliers", "High Outliers", 
                            "Outlier %", "Median Count", "Q1", "Q3"),
               digits = c(0, 0, 0, 0, 1, 0, 0, 0))
} else {
  cat("No outlier detection results available.\n")
}
```

### Distribution of Feature Counts

```{r qc-distribution-plot}
#| fig-cap: "Distribution of total counts per feature across all matrices. Red points show outliers detected using the IQR method."
#| fig-width: 12
#| fig-height: 8

# Only create plot if we have outlier results
if (length(outlier_results) > 0 && any(sapply(outlier_results, function(x) length(x$feature_totals) > 0))) {
  
  # Prepare data for plotting
  plot_data <- data.frame()
  for (name in names(outlier_results)) {
    result <- outlier_results[[name]]
    if (length(result$feature_totals) > 0) {
      matrix_data <- data.frame(
        Matrix = name,
        Feature_Total = result$feature_totals,
        Is_Outlier = seq_along(result$feature_totals) %in% result$outlier_indices
      )
      plot_data <- rbind(plot_data, matrix_data)
    }
  }
  
  # Only proceed if we have plot data
  if (nrow(plot_data) > 0) {
    # Add species and feature type for better grouping
    plot_data$Species <- case_when(
      grepl("Apul", plot_data$Matrix) ~ data_urls[["Apul"]]$species_name,
      grepl("Peve", plot_data$Matrix) ~ data_urls[["Peve"]]$species_name,
      grepl("Ptuh", plot_data$Matrix) ~ data_urls[["Ptuh"]]$species_name,
      TRUE ~ "Unknown"
    )
    
    plot_data$Feature_Type <- case_when(
      grepl("gene", plot_data$Matrix) ~ "Gene",
      grepl("mirna", plot_data$Matrix) ~ "miRNA",
      grepl("lncRNA", plot_data$Matrix) ~ "lncRNA",
      grepl("mCpG", plot_data$Matrix) ~ "mCpG",
      TRUE ~ "Unknown"
    )
    
    # Filter out rows with unknown species or feature types
    plot_data <- plot_data[plot_data$Species != "Unknown" & plot_data$Feature_Type != "Unknown", ]
    
    if (nrow(plot_data) > 0) {
      # Create the plot
      p2 <- ggplot(plot_data, aes(x = Feature_Type, y = log10(Feature_Total + 1))) +
        geom_boxplot(aes(fill = Species), alpha = 0.7, outlier.shape = NA) +
        geom_point(data = plot_data[plot_data$Is_Outlier, ], 
                   color = "red", 
                   position = position_jitter(width = 0.2),
                   size = 0.8, alpha = 0.6) +
        scale_fill_manual(values = c("#E31A1C", "#1F78B4", "#33A02C")) +
        facet_wrap(~ Species, scales = "free_y") +
        labs(
          title = "Distribution of Feature Counts with Outlier Detection",
          subtitle = "Log10-transformed total counts per feature across samples",
          x = "Feature Type",
          y = "Log10(Total Count + 1)",
          fill = "Species"
        ) +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 14, face = "bold"),
          plot.subtitle = element_text(size = 12),
          strip.text = element_text(size = 11, face = "bold"),
          axis.title = element_text(size = 11),
          legend.position = "bottom",
          panel.grid.minor = element_blank()
        )
      
      print(p2)
    } else {
      cat("No valid data available for distribution visualization.\n")
    }
  } else {
    cat("No data available for distribution visualization.\n")
  }
} else {
  cat("No outlier detection results available for visualization.\n")
}
```

::: callout-note
## Quality Control Interpretation

**Sample Count Variation**: The visualizations reveal significant variation in sample sizes across matrices, with gene expression consistently having the most samples and methylation data showing the greatest between-species variation.

**Outlier Features**: Features identified as outliers may represent:
- **High outliers**: Highly expressed genes, abundant miRNAs, or hypermethylated regions
- **Low outliers**: Lowly expressed features that may be technical artifacts or rare biological events

Consider filtering extreme outliers in downstream analyses, but retain biologically relevant high-abundance features.
:::

### Feature Count Summary by Matrix

```{r qc-summary-plot}
#| fig-cap: "Summary statistics for feature counts across all count matrices showing median and quartile ranges."
#| fig-width: 10
#| fig-height: 6

# Only create plot if we have data
if (exists("plot_data") && nrow(plot_data) > 0) {
  # Create summary statistics plot
  summary_stats <- plot_data %>%
    group_by(Matrix, Species, Feature_Type) %>%
    summarise(
      Median = median(Feature_Total, na.rm = TRUE),
      Q1 = quantile(Feature_Total, 0.25, na.rm = TRUE),
      Q3 = quantile(Feature_Total, 0.75, na.rm = TRUE),
      Outliers = sum(Is_Outlier),
      .groups = 'drop'
    )
  
  if (nrow(summary_stats) > 0) {
    p3 <- ggplot(summary_stats, aes(x = Feature_Type, y = log10(Median + 1), fill = Species)) +
      geom_col(position = "dodge", alpha = 0.8) +
      geom_text(aes(label = paste0("n=", Outliers)), 
                position = position_dodge(width = 0.9), 
                vjust = -0.3, size = 3) +
      scale_fill_manual(values = c("#E31A1C", "#1F78B4", "#33A02C")) +
      labs(
        title = "Median Feature Counts and Outlier Numbers by Matrix",
        subtitle = "Numbers above bars show count of outlier features",
        x = "Feature Type",
        y = "Log10(Median Count + 1)",
        fill = "Species"
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 14, face = "bold"),
        plot.subtitle = element_text(size = 12),
        axis.title = element_text(size = 11),
        legend.position = "bottom",
        panel.grid.minor = element_blank()
      )
    
    print(p3)
  } else {
    cat("No summary statistics available for visualization.\n")
  }
} else {
  cat("No data available for summary visualization.\n")
}
```

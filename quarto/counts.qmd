---
title: "Expression Values"
description: "Count Matrices"
format:
  html:
    code-copy: true
    toc: true
    toc-location: right
    toc-expand: true
editor: visual
execute:
  echo: false
  warning: false
  message: false
---

```{r setup, include=FALSE}
library(tidyverse)
library(DT)
library(readxl)
library(plotly)
library(readr)
library(dplyr)
library(tibble)
library(knitr)
library(gt)
library(htmltools)
```

```{r, cache=TRUE, include=FALSE}


# Define key paths and tool directories


Apul_gene_url <- "https://gannet.fish.washington.edu/gitrepos/urol-e5/timeseries_molecular/D-Apul/output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv"

Apul_mirna_url <- "https://raw.githubusercontent.com/urol-e5/timeseries_molecular/refs/heads/main/M-multi-species/output/10-format-miRNA-counts/Apul_miRNA_counts_formatted.txt"

Apul_lncRNA_url <- "https://gannet.fish.washington.edu/v1_web/owlshell/bu-github/timeseries_molecular/D-Apul/output/33-Apul-lncRNA-matrix/Apul_lncRNA_counts_filtered.txt"

Apul_mCpG_url <- "https://gannet.fish.washington.edu/metacarcinus/E5/20250821_meth_Apul/merged-WGBS-CpG-counts_filtered.csv"


Peve_gene_url <- "https://gannet.fish.washington.edu/gitrepos/urol-e5/timeseries_molecular/E-Peve/output/02.20-E-Peve-RNAseq-alignment-HiSat2/peve-gene_count_matrix.csv"

Peve_mirna_url <- "https://raw.githubusercontent.com/urol-e5/timeseries_molecular/refs/heads/main/M-multi-species/output/10-format-miRNA-counts/Peve_miRNA_counts_formatted.txt"

Peve_lncRNA_url <- "https://gannet.fish.washington.edu/v1_web/owlshell/bu-github/timeseries_molecular/E-Peve/output/13-Peve-lncRNA-matrix/Peve_lncRNA_counts_filtered.txt"

#Peve_mCpG_url <- "https://gannet.fish.washington.edu/metacarcinus/E5/Pevermanni/20250728_meth_Peve/merged-WGBS-CpG-counts.csv"


Ptuh_gene_url <- "https://gannet.fish.washington.edu/gitrepos/urol-e5/timeseries_molecular/F-Ptua/output/02.20-F-Ptua-RNAseq-alignment-HiSat2/ptua-gene_count_matrix.csv"

Ptuh_mirna_url <- "https://raw.githubusercontent.com/urol-e5/timeseries_molecular/refs/heads/main/M-multi-species/output/10-format-miRNA-counts/Ptua_miRNA_counts_formatted.txt"

#Peve_lncRNA_url <- "https://gannet.fish.washington.edu/v1_web/owlshell/bu-github/timeseries_molecular/E-Peve/output/13-Peve-lncRNA-matrix/Peve_lncRNA_counts_filtered.txt"

#Peve_mCpG_url <- "https://gannet.fish.washington.edu/metacarcinus/E5/Pevermanni/20250728_meth_Peve/merged-WGBS-CpG-counts.csv"



# read in 


Apul_gene <- read_csv(Apul_gene_url)
Apul_mirna <- read_delim(Apul_mirna_url, delim = "\t", col_names = TRUE)
Apul_lncRNA <- read_delim(Apul_lncRNA_url, delim = "\t", col_names = TRUE, skip = 7)
Apul_mCpG <- read_csv(Apul_mCpG_url)


Peve_gene <- read_csv(Peve_gene_url)
Peve_mirna <- read_delim(Peve_mirna_url, delim = "\t", col_names = TRUE)
Peve_lncRNA <- read_delim(Peve_lncRNA_url, delim = "\t", col_names = TRUE, skip = 7)
#Peve_mCpG <- read_csv(Peve_mCpG_url)


```

*Acropora pulchra* - we have data on **`r nrow(Apul_gene)`** genes, **`r nrow(Apul_mirna)`** miRNAs, **`r nrow(Apul_lncRNA)`** lncRNAs, and **`r nrow(Apul_mCpG)`** mCpGs.

*Porites evermanni* - we have data on **`r nrow(Peve_gene)`** genes, **`r nrow(Peve_mirna)`** miRNAs, **`r nrow(Peve_lncRNA)`** lncRNAs,, and **`nrow(Peve_mCpG)`** mCpGs.

## About Computational Pipelines

::: panel-tabset
## Genes

This workflow aligns trimmed *Acropora pulchra* RNA-seq reads to the reference genome using HISAT2, followed by transcript assembly and quantification with StringTie, and culminates in the generation of count matrices for downstream expression analysis. It begins by defining environment variables and downloading/verifying input FastQs, then loops through each sample to run HISAT2 alignments, process outputs with samtools (flagstat, sort, index), and assemble transcripts with StringTie while recording file provenance via checksums. Individual sample directories contain BAMs, indexes, GTFs, Ballgown-formatted tables, and alignment statistics, while a MultiQC report aggregates overall alignment quality. The workflow then merges sorted BAMs into a single dataset, compiles a unified transcript GTF from individual assemblies, and uses prepDE to produce gene- and transcript-level count matrices compatible with DESeq2. 

## miRNA

ShortStack ? Kathleen

## lncRNA

Workflow downloads trimmed paired-end FASTQs and the reference genome/annotations, builds a splice-aware HISAT2 index from the GTF (exons + splice sites), and aligns all samples; SAM files are converted to sorted, indexed BAMs. Per-sample transcript assemblies are generated with StringTie and merged into a unified GTF, which is then annotated with gffcompare. Putative lncRNAs are filtered from the merged annotations by biotype/class codes (u/x/o/i) and minimum length (\>200 nt), sequences are extracted with bedtools, and coding potential is screened with CPC2 to retain noncoding transcripts. The surviving transcripts are converted into a clean BED/GTF set with unique lncRNA\_### IDs, deduplicated, sanity-checked (coordinates/lengths), and summarized. Finally, featureCounts quantifies lncRNA features across all BAMs, column names are cleaned, and a filtered count matrix is produced (removing rows with \<10 counts in \>50% of samples).

## mCpG

This workflow outlines bisulfite sequencing (WGBS) analysis pipeline that processes Bismark methylation coverage (.cov) files into unified CpG methylation matrices. First, .cov.gz are filterde for CpG sites with ≥10× coverage and converts them into bedgraph files. Each bedgraph is reformatted into a simplified two-column \_processed.txt file containing unique CpG IDs and percent methylation values. A Python script then merges all \_processed.txt files into a single matrix (merged-WGBS-CpG-counts.csv), with CpG loci as rows and samples as columns. Only loci where 10x coverage is present in all samples is retained.
:::

::: callout-tip
## ConTra

If you are exciting about analyzing this type of data in contextual manner check out [ConTra - Contextual Transcriptome Regulation Analysis](https://github.com/sr320/ConTra)
:::

::: callout-warning
## Sample ID formatting

Note currently we have some inconsistency in sample IDs across data types.
:::

# *Acropora pulchra*

## Gene Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Apul_gene_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Apul_gene_count_matrix.csv",
    "Download Gene Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Apul_gene_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
Apul_gene |>
  rowid_to_column("Row") |>
  slice_head(n = 4) |>
  gt()
```

## miRNA Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Apul_mirna_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Apul_gene_count_matrix.csv",
    "Download miRNA Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Apul_mirna_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
Apul_mirna |>
  rowid_to_column("Row") |>
  slice_head(n = 4) |>
  gt()
```

## lncRNA Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Apul_lncRNA_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Apul_gene_count_matrix.csv",
    "Download lncRNA Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Apul_lncRNA_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
#| tbl-cap: "Apul_lncRNA (first 10 rows with row numbers)"
Apul_lncRNA |>
  rowid_to_column("Row") |>
  slice_head(n = 4) |>
  gt()
```

## mCpG Percentage

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Apul_mCpG_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Apul_gene_count_matrix.csv",
    "Download MCpG Percentage"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Apul_mCpG_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
#| tbl-cap: "Apul_mCpG (first 10 rows with row numbers)"
Apul_mCpG |>
  rowid_to_column("Row") |>
  slice_head(n = 4) |>
  gt()
```

# *Porites evermanni*

## Gene Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Peve_gene_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Peve_gene_count_matrix.csv",
    "Download Gene Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Peve_gene_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
Peve_gene |>
  rowid_to_column("Row") |>
  slice_head(n = 4) |>
  gt()
```

## miRNA Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Peve_mirna_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Peve_gene_count_matrix.csv",
    "Download miRNA Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Peve_mirna_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
Peve_mirna |>
  rowid_to_column("Row") |>
  slice_head(n = 4) |>
  gt()
```

## lncRNA Counts

```{r}
#| echo: false
#| results: asis


cat(as.character(
  tags$a(
    href = Peve_lncRNA_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Peve_gene_count_matrix.csv",
    "Download lncRNA Counts"
  )
))
```

```{r}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Peve_lncRNA_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r}
#| tbl-cap: "Peve_lncRNA (first 10 rows with row numbers)"
Peve_lncRNA |>
  rowid_to_column("Row") |>
  slice_head(n = 4) |>
  gt()
```

## mCpG Percentages

```{r, eval=FALSE, include=FALSE}
#| results: asis


cat(as.character(
  tags$a(
    href = Peve_mCpG_url,
    class = "btn btn-primary",
    target = "_blank",
    download = "Peve_gene_count_matrix.csv",
    "Download mCpG Percentage"
  )
))
```

```{r, eval=FALSE, include=FALSE}
#| results: asis
# (YAML already has format: html: code-copy: true)

#labs <- c("direct url")
urls <- c(Peve_mCpG_url)

for (i in seq_along(urls)) {
  #cat("**", labs[i], "**\n\n", sep = "")
  # Use bash so Quarto shows a copy button for each block
  cat("``` bash\n", urls[i], "\n```\n\n", sep = "")
}
```

```{r, eval=FALSE, include=FALSE}
#| tbl-cap: "Peve_mCpG (first 10 rows with row numbers)"
Peve_mCpG |>
  rowid_to_column("Row") |>
  slice_head(n = 4) |>
  gt()
```

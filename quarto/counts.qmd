---
title: "Expression Values"
description: "Count Matrices"
format:
  html:
    code-copy: true
    toc: true
    toc-location: right
    toc-expand: true
editor: visual
execute:
  echo: false
  warning: false
  message: false
---

```{r setup, include=FALSE}
library(tidyverse)
library(DT)
library(readxl)
library(plotly)
library(readr)
library(dplyr)
library(tibble)
library(knitr)
library(gt)
library(htmltools)
```

```{r, cache=TRUE, include=FALSE}

# =============================================================================
# EXTERNAL DATA URLS CONFIGURATION
# =============================================================================
# All external URLs are centralized here for easy maintenance.
# To update URLs, only modify this section.

data_urls <- list(
  Apul = list(
    species_name = "Acropora pulchra",
    italic_name = "*Acropora pulchra*",
    gene = "https://gannet.fish.washington.edu/gitrepos/urol-e5/timeseries_molecular/D-Apul/output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv",
    mirna = "https://raw.githubusercontent.com/urol-e5/timeseries_molecular/refs/heads/main/M-multi-species/output/10-format-miRNA-counts/Apul_miRNA_counts_formatted.txt",
    lncRNA = "https://gannet.fish.washington.edu/v1_web/owlshell/bu-github/timeseries_molecular/D-Apul/output/33-Apul-lncRNA-matrix/Apul_lncRNA_counts_filtered.txt",
    mCpG = "https://gannet.fish.washington.edu/metacarcinus/E5/20250821_meth_Apul/merged-WGBS-CpG-counts_filtered.csv"
  ),
  Peve = list(
    species_name = "Porites evermanni",
    italic_name = "*Porites evermanni*",
    gene = "https://gannet.fish.washington.edu/gitrepos/urol-e5/timeseries_molecular/E-Peve/output/02.20-E-Peve-RNAseq-alignment-HiSat2/peve-gene_count_matrix.csv",
    mirna = "https://raw.githubusercontent.com/urol-e5/timeseries_molecular/refs/heads/main/M-multi-species/output/10-format-miRNA-counts/Peve_miRNA_counts_formatted.txt",
    lncRNA = "https://gannet.fish.washington.edu/v1_web/owlshell/bu-github/timeseries_molecular/E-Peve/output/13-Peve-lncRNA-matrix/Peve_lncRNA_counts_filtered.txt",
    mCpG = "https://gannet.fish.washington.edu/metacarcinus/E5/Pevermanni/20250821_meth_Peve/merged-WGBS-CpG-counts_filtered.csv"
  ),
  Ptuh = list(
    species_name = "Pocillopora tuahiniensis",
    italic_name = "*Pocillopora tuahiniensis*",
    gene = "https://gannet.fish.washington.edu/gitrepos/urol-e5/timeseries_molecular/F-Ptua/output/02.20-F-Ptua-RNAseq-alignment-HiSat2/ptua-gene_count_matrix.csv",
    mirna = "https://raw.githubusercontent.com/urol-e5/timeseries_molecular/refs/heads/main/M-multi-species/output/10-format-miRNA-counts/Ptuh_miRNA_counts_formatted.txt",
    lncRNA = "https://raw.githubusercontent.com/urol-e5/timeseries_molecular/refs/heads/main/F-Ptua/output/06-Ptua-lncRNA-discovery/lncRNA_counts.clean.filtered.txt",
    mCpG = "https://gannet.fish.washington.edu/metacarcinus/E5/Ptuahiniensis/20250821_meth_Ptua/merged-WGBS-CpG-counts_filtered.csv"
  )
)

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

# Function to create download button
create_download_button <- function(url, filename, button_text) {
  as.character(
    tags$a(
      href = url,
      class = "btn btn-primary",
      target = "_blank",
      download = filename,
      button_text
    )
  )
}

# Function to display URL in code block
display_url <- function(url) {
  cat("``` bash\n", url, "\n```\n\n", sep = "")
}

# Function to load data with appropriate parameters
load_data_file <- function(url, data_type, species_code) {
  tryCatch({
    if (data_type == "gene" || data_type == "mCpG") {
      read_csv(url, show_col_types = FALSE)
    } else if (data_type == "mirna") {
      read_delim(url, delim = "\t", col_names = TRUE, show_col_types = FALSE)
    } else if (data_type == "lncRNA") {
      if (species_code %in% c("Apul", "Peve")) {
        read_delim(url, delim = "\t", col_names = TRUE, skip = 7, show_col_types = FALSE)
      } else {
        read_delim(url, delim = "\t", col_names = TRUE, show_col_types = FALSE)
      }
    }
  }, error = function(e) {
    warning(paste("Failed to load", data_type, "data for", species_code, ":", e$message))
    return(data.frame())
  })
}

# =============================================================================
# DATA LOADING
# =============================================================================

# Load all data files
all_data <- list()
for (species_code in names(data_urls)) {
  all_data[[species_code]] <- list()
  for (data_type in c("gene", "mirna", "lncRNA", "mCpG")) {
    url <- data_urls[[species_code]][[data_type]]
    all_data[[species_code]][[data_type]] <- load_data_file(url, data_type, species_code)
  }
}

```


```{r}
#| echo: false
# Generate feature counts table dynamically
feature_counts <- data.frame(
  Species = character(),
  Gene = integer(),
  miRNA = integer(),
  lncRNA = integer(),
  mCpG = integer(),
  stringsAsFactors = FALSE
)

for (species_code in names(data_urls)) {
  feature_counts <- rbind(feature_counts, data.frame(
    Species = data_urls[[species_code]]$italic_name,
    Gene = nrow(all_data[[species_code]]$gene),
    miRNA = nrow(all_data[[species_code]]$mirna),
    lncRNA = nrow(all_data[[species_code]]$lncRNA),
    mCpG = nrow(all_data[[species_code]]$mCpG),
    stringsAsFactors = FALSE
  ))
}

feature_counts |>
  gt() |>
  tab_header(title = "Feature Counts") |>
  fmt_number(columns = c("Gene", "miRNA", "lncRNA", "mCpG"), decimals = 0) |>
  cols_align(align = "center", columns = c("Gene", "miRNA", "lncRNA", "mCpG")) |>
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(columns = c("Gene", "miRNA", "lncRNA", "mCpG"))
  )
```

::: callout-note
## Easy URL Management

**To update external data URLs:** All URLs are centralized in the `data_urls` configuration at the top of the R code block. Simply modify the URLs in that single location - no need to search and replace throughout the document.

**Structure:** Each species has four data types (gene, mirna, lncRNA, mCpG) with their respective URLs organized in a clear nested list structure.
:::

::: callout-tip
## ConTra

If you are excited about analyzing this type of data in contextual manner check out [ConTra - Contextual Transcriptome Regulation Analysis](https://github.com/sr320/ConTra)
:::

## About Computational Pipelines

::: panel-tabset
## Genes

This workflow aligns trimmed RNA-seq reads to a reference genome using HISAT2, followed by transcript assembly and quantification with StringTie, and culminates in the generation of count matrices for downstream expression analysis. Individual sample directories contain BAMs, indexes, GTFs, Ballgown-formatted tables, and alignment statistics, while a MultiQC report aggregates overall alignment quality. The workflow then merges sorted BAMs into a single dataset, compiles a unified transcript GTF from individual assemblies, and uses prepDE to produce gene- and transcript-level count matrices compatible with DESeq2. 

## miRNA

ShortStack ? Kathleen

## lncRNA

Workflow builds a splice-aware HISAT2 index from the GTF (exons + splice sites), and aligns all samples. Per-sample transcript assemblies are generated with StringTie and merged into a unified GTF, which is then annotated with gffcompare. Putative lncRNAs are filtered from the merged annotations by biotype/class codes (u/x/o/i) and minimum length (\>200 nt), sequences are extracted with bedtools, and coding potential is screened with CPC2 to retain noncoding transcripts. The surviving transcripts are converted into a clean BED/GTF set with unique lncRNA\_### IDs, deduplicated, sanity-checked (coordinates/lengths), and summarized. Finally, featureCounts quantifies lncRNA features across all BAMs, column names are cleaned, and a filtered count matrix is produced, removing features with \<10 counts in \>50% of samples.

## mCpG

For EM-seq analysis Bismark methylation coverage (.cov) files are unified into CpG methylation matrices. First, .cov.gz are filtered for CpG sites with ≥10× coverage and converts them into bedgraph files. Each bedgraph is reformatted into a simplified two-column \_processed.txt file containing unique CpG IDs and percent methylation values. A Python script then merges all \_processed.txt files into a single matrix, with CpG loci as rows and samples as columns. Only loci where 10x coverage is present in all samples are retained.
:::

::: callout-warning
## Sample ID formatting

Note currently we have some inconsistency in sample IDs across data types.
:::

# =============================================================================
# DYNAMIC CONTENT GENERATION FUNCTIONS
# =============================================================================

```{r, include=FALSE}
# Function to generate a data section (Gene, miRNA, lncRNA, or mCpG)
generate_data_section <- function(species_code, data_type) {
  species_info <- data_urls[[species_code]]
  url <- species_info[[data_type]]
  data <- all_data[[species_code]][[data_type]]
  
  # Capitalize data type for display
  data_type_display <- switch(data_type,
    "gene" = "Gene",
    "mirna" = "miRNA", 
    "lncRNA" = "lncRNA",
    "mCpG" = "mCpG Percentage"
  )
  
  # Generate filename for download
  file_extension <- if (data_type %in% c("gene", "mCpG")) ".csv" else ".txt"
  filename <- paste0(species_code, "_", data_type, "_counts", file_extension)
  
  # Generate section header
  cat("## ", data_type_display, "\n\n", sep = "")
  
  # Generate download button
  cat("```{r}\n#| echo: false\n#| results: asis\n\n")
  cat("cat(create_download_button(\n")
  cat("  '", url, "',\n", sep = "")
  cat("  '", filename, "',\n", sep = "")
  cat("  'Download ", data_type_display, "'\n")
  cat("))\n")
  cat("```\n\n")
  
  # Generate URL display
  cat("```{r}\n#| results: asis\n\n")
  cat("display_url('", url, "')\n", sep = "")
  cat("```\n\n")
  
  # Generate data preview
  table_caption <- paste0(species_code, "_", data_type, " (first 4 rows)")
  cat("```{r}\n#| tbl-cap: '", table_caption, "'\n", sep = "")
  cat("all_data[['", species_code, "']][['", data_type, "']] |>\n", sep = "")
  cat("  slice_head(n = 4) |>\n")
  cat("  gt()\n")
  cat("```\n\n")
}

# Function to generate a complete species section
generate_species_section <- function(species_code) {
  species_info <- data_urls[[species_code]]
  
  # Generate species header
  cat("# ", species_info$italic_name, "\n\n", sep = "")
  
  # Generate each data type section
  for (data_type in c("gene", "mirna", "lncRNA", "mCpG")) {
    generate_data_section(species_code, data_type)
  }
}
```

```{r}
#| echo: false
#| results: asis

# Generate all species sections
for (species_code in names(data_urls)) {
  generate_species_section(species_code)
}
```
